# 第三章8086微处理器

## 8086寄存器
![CPU内部结构.png](https://i.loli.net/2020/09/06/5E26M4VaLDh1NHf.png)

8086/8088微处理器中可供程序员使用的有14个16位寄存器，按照用途可分为`通用寄存器`、`指令指针`、`控制寄存器`和`段寄存器`等4类。

![14个寄存器.png](https://i.loli.net/2020/09/06/oJLkr6HvNAEq5cP.png)

### 通用寄存器

#### 数据寄存器
| 15-8 | 7-0  | 
| :--: | :--: |  
|  AH  | AL   | 
|  BH  | BL   |
|  CH  | CL   |
|  DH  | DL   |

##### AX累加器
1. 存放数据
2. IO指令中提供/存储操作数(AX/AL)
```
IN AL, 12H
```

##### BX基础寄存器
1. 存放数据
2. 可以提供偏移地址
```
MOV AX,BX     BX当作数据
MOV AX,[BX]   将内存中的数据段中偏移地址为BX的值赋给AX
```

##### CX计数寄存器
1. 存放数据
2. 可以提供循环程序的循环次数，`loop`会使`CX`自减一。

##### DX数据寄存器
1. 存放数据
2. 在乘除法提供一个默认操作数
```
DIV BX;
(DX AX)/BX       由DX和AX组成一个32位操作数
```
3. 提供IO端口地址
```
OUT DX,AL
```

#### 指针寄存器

| 15-0 |
| :--: |
|  SP  |
|  BP  |

##### SP堆栈指针寄存器
1. 堆栈操作指令PUSH和POP访问

##### BP基址
1. 可以默认提供堆栈段的偏移地址但是PUSH和POP不能访问

#### 变址寄存器 

| 15-0 |
| :--: |
|  SI  |
|  DI  |

##### SI源变址寄存器DI目的变址寄存
1. 在串操作指令中分别指向原串和目的串

### 段寄存器

| 15-0 | 名称 |
| :--: | :--: |
|  CS  | 代码段寄存器 |
|  DS  | 数据段寄存器 |
|  SS  | 堆栈段寄存器 |
|  ES  | 附加数据段寄存器 |

1. 用来提供段地址

### 控制寄存器

| 15-0 |
| :--: |
|  IP  |
|  BP  |

#### IP指令指针寄存器
1. 指向CPU即将取用的位置

#### FLAGS状态标志寄存器
1. 查看状态
```
8086/8088有一个16位的标志寄存器FLAGS,在FLAGS中有意义的有9位，其中6位是状态位：CF、PF、AF、ZF、SF、OF,3位是控制位:TF、IF、DF。
```
| 15  | 14  | 13  | 12  | 11  | 10  | 9   | 8   | 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
|     |     |     |     | O   | D   | I   | T   | S   | Z   |     | A   |     | P   |     | C   |  

`状态标志位:表示处理器当前的运行状态`  
CF--进位标志，运算结果有进(借)位,CF=1  
AF--辅助进位标志，低4位向前有进(借)位,AF=1  
ZF--零标志,结果为0,ZF=1  
SF--符号标志,最高位的值  
OF--溢出标志位,带符号数,双高为判别法(数值位往上进位和符号位往上进位的异或)  
PF--奇/偶标志,运算结果低8位中1的个数位偶数个PF=1    
`控制标志:控制处理器的某一特定功能`  
IF--可屏蔽中断允许标志,IF=1表示允许  
DF--方向标志,DF=0地址增量变化;DF=1地址减量变化;  
TF--陷阱标志(单步执行标志)  

### 偏移地址和段寄存器的默认关系
- CS--IP
- DS--BX,SI,DI,位移量
- SS--BP,SP
- ES--DI(串操作)

## 8086微处理器引脚功能
![80868088引脚.png](https://i.loli.net/2020/09/06/cC5FZJQ839Naoiv.png)  
AB:20,DB:16,CB:16,VCC:1,GND:2,CLK:1;  
1. AD15\~AD0为地址/数据总线(分时复用,1/4为地址总线,3/4为数据总线);A19-A16/S6\~S3为地址/状态总线。
2. 数据总线用来在CPU与内存储器或IO设备之间交换信息,为双向、三态信号;
3. 地址总线由CPU发出,用来确定CPU要访问的内存单元(或I/O端口)的地址信号,为输出、三态信号。
4. CLK:时钟信号输入,为8086CPU提供基本的定时脉冲,其占空比为1:3,以提供最佳的内部定时。
5. MN/MX:高电平为最小工作方式,单CPU工作,低电平为最大工作方式,多处理器合作。
6. RESET:输入,为高时,CPU执行复位;
7. NMI:非屏蔽中断请求信号(不可屏蔽中断请求);
8. INTR:可屏蔽中断请求
9. INTA:中断响应信号
10. RD:读信号
11. WR(LOCK):写信号
12. M/IO(S2):指出当前访问的是内存还是IO接口
13. READY:表示数据准备好的信号,CPU在T3状态查询该信号,如果有效,说明数据准备好了,否则插入若干个等待状态TW;
14. BHE/S7:高8位数据线允许信号,低表示高8位有效,高表示低8位有效。
15. ALE:地址锁存信号,在第一个时钟周期结束后,ALE由高变低时锁存。
16. DT/R:表示数据传送方向,高:CPU输出,低:CPU输入。
17. DEN:数据是否允许通过,低电平表示有效,高电平无效。
18. HOLD:总线请求信号
19. HLDA:当CPU收到HOLD时,不需要在使用总线时发送HLDA信号。
20. TEST:用于CPU与外部硬件同步,当CPU在执行WAIT指令时,CPU会对该引脚进行测试。

# 第四章8086指令系统

## 8086/8088指令系统的寻址方式  
寻找操作数存放地址的方法。  
1. 操作数可以包含在指令字节中，叫做`立即数操作数`。
2. 操作数可以放在CPU的某个内部寄存器中，这种操作数叫做`寄存器操作数`。
3. 操作数在内存数据区中，位`存储器操作数`。
4. 操作数来自或送到I/O端口中，叫`I/O操作数`。
在8086/8088系统中，操作数又分为两大类:`数据操作数`和`地址操作数`。寻址方式为`数据寻址方式`和`地址寻址方式`两个类。  

### 立即数寻址方式
![立即数寻址方式.png](https://i.loli.net/2020/09/06/9Hki5JwlTR3WdMb.png)  
立即数寻址方式一般都为常量,包含在指令码中。  

### 寄存器寻址方式
![可存放数据的寄存器.png](https://i.loli.net/2020/09/06/tGg5Ee1FPxUO7uH.png)  
![寄存器寻址方式.png](https://i.loli.net/2020/09/06/gmMUDTqAtEhczK6.png)  

### IO端口寻址方式  
1. 直接端口寻址方式(小于FFH)
```
IN AL,21H
```
![直接寻址方式.png](https://i.loli.net/2020/09/06/FeOf4Novpd7GlXn.png)  
2. 间接端口寻址方式  
![间接寻址方式.png](https://i.loli.net/2020/09/06/3r2wtix9EgTBQGo.png)  

### 存储器寻址方式
1. 直接寻址方式(数值,物理地址)  
![存储器直接寻址.png](https://i.loli.net/2020/09/06/EVgNZ3JGh8dpcU1.png)
2. 间接寻址方式  
![存储器间接寻址.png](https://i.loli.net/2020/09/06/ER83UCPfXgnqueV.png)  
3. 寄存器相对寻址方式  
![存储器寻址相对寻址.png](https://i.loli.net/2020/09/06/I21sbqTKE4oV3fR.png)
4. 基址加变址寻址方式  
![存储器基址加变址寻址.png](https://i.loli.net/2020/09/06/lvyOZBj2IDFgqUb.png)
5. 基址加变址相对寻址  
![存储器寻址基址加变址相对寻址.png](https://i.loli.net/2020/09/06/DAhEY5Ol4GVtRB7.png)

## 地址寻址方式

### 段内直接寻址方式  
转移的地址是当前IP内容和指令规定的8位或16位位移量之和。  
当转移两是8位时,称为`短程转移`,通常在目标地址前加操作符`SHORT`;位移量是16位时称为`近程转移`,在目标地址前加操作符`NEAR PTR`。  

### 段内间接寻址方式(只变IP,不变CS)
```
JMP BX
JMP WORD PTR ADDR
JMP WORD PTR [BX+ARRY]
```

### 段间直接寻址方式(都变)  
![段内直接寻址.png](https://i.loli.net/2020/09/06/lgVrqpO2FvD9BEw.png)

### 段间间接寻址方式  
![段间间接寻址方式.png](https://i.loli.net/2020/09/06/b58ID1LnmKgdzOf.png)
![段间间接寻址方式.png](https://i.loli.net/2020/09/06/x2yzM5aLPsUS71W.png)

## 数据传送指令

### 最基本的传送指令`MOV`
```
MOV dst,src;   (dst)<--(src)
dst 目的操作数
src 源操作数
源操作数放入目的操作数
```

### 堆栈操作指令(不支持立即数)
堆栈操作指令是用来完成压入和弹出堆栈操作的。

#### 压入堆栈指令
```
PUSH scr;    (SP)<--(SP)-2,
			 ((SP)+1:(SP))<--(src)
```

#### 弹出堆栈指令
```
POP dst;     (dst)<--((SP)+1:(SP)),
             (SP)<--(SP)+2
```

#### 交换指令XCHE(Exchange)
```
格式:XCHEG OPR1,OPR2
执行操作:OPR1 <=> OPR2
说明:
- 两个操作数中必须有一个是寄存器
- 段寄存器不能交换
- 不支持立即数
```

### 累加器专用指令

#### 输入/输出指令
1. 直接寻址的输入指令
```
IN acc,port;    (acc)<--(port)
```

2. 间接寻址的输入指令
```
IN acc,DX;      (acc)<--((DX))
```

3. 直接寻址的输出指令
```
OUT port,acc;   (port)<--(acc)
```

4. 间接寻址的输出指令
```
OUT DX,acc;     ((DX))<--(acc)
```

#### 字节转换指令
指令格式及操作:
```
XLAT src_table; (AL)<--((BX)+(AL))
```
使用前建立一个字节表格,表格的首址存入BX,要转换的代码放入AL,然后执行XLAT,在AL中得到转换以后的代码。

### 地址传送指令
1. 取有效地址指令
```
LEA reg16,mem
将源操作数的16位偏移地址,送到一个16位的通用寄存器中。
```
2. 地址指针装入DS指令
```
指令格式:
LDS reg16,mem32
此指令的功能是将源操作数所对应的双字节的内存单元中的高字节(一般为16位段基址)送入DS,低字节内容(一般为偏移地址)送入指令所指定的寄存器中。
例如:LDS DI,[2130H]
```
3. 地址指针装入ES指令
```
指令格式:LES reg16,mem32
将源操作数高子内容送入ES,低字内容放入指定寄存器中。
例如:LES DI,[2130H]
```

### 标志传送指令
1. 取标志指令
指令格式:LAHF
FLAGS低八位内容放入AH
2. 置标志指令
指令格式:SAHF
AH内容放入FLAGS低八位
3. 标志压入堆栈指令
```
指令格式:PUSHF;  (SP)<--(Sp)-2,  
                ((SP)+1;(SP))<--(FLAG)
```
4. 标志弹出堆栈指令
```
指令格式:POPF;   (FLAG)<--((SP)+1;(SP)),
                (SP)<--(SP)+2
```

## 算术运算类指令

### 加法指令
- `ADD(add)`加法  
格式:ADD DST,SRC  
操作:DST <= DST + SRC
- `ADC`带进位的加法  
格式:ADC DST,SRC  
操作:DST <= DST + SRC + CF
- `INC`加1  
格式:INC DST  
操作:DST <= DST + 1  

**如要计算两个十六进制数之和**
```
	   MOV CX,5;           设置循环次数
	   MOV SI,0;           位移量
	   CLC;                清除CF位
LOOPER:MOV AL,DATA2[SI];   取一个加数
       ADC DATA1[SI],AL;   和一个被加数加
	   INC SI;             SI加1
	   DEC CX;             CX减1
	   JNZ LOOPER;         跳转
	   HLT;                结束
```

### 减法指令
- `SUB`减法  
格式: SUB DST,SRC  
操作: DST=DST-SRC  
- `SBB`带借位的减法  
格式: SBB DST,SRC  
操作: DST<=DST-SRC-CF  
- `DEC`减1  
格式: DEC DST  
操作: DST=DST-1  
- `NEG`求补  
格式:NEG DST  
操作:DST<=0-DST  
利用NEG指令获得负数的绝对值  
- `CMP`比较  
格式:CMP DST,SRC;  
操作:DST-SRC  
相当于减法,但不保存结果,仅影响标志。

### 乘法指令
- `MUL`无符号乘法  
格式:MUL SRC  
操作:AX<=AL*SRC(字节)/DX,AX<=AX*SRC(字)
- `IMUL`有符号数乘法  
格式:IMUL SRC  
操作:类似MUL。  
默认使用AX或DX,AX为目的操作数。

### 除法指令
- `DIV`无符号数除法  
操作:  
1. 字节除法:AX/SRC,商=>AL,余数=>AH
2. 字除法:DX,AX/SRC,商=>AX,预处=>DX  
- `IDIV`有符号数除法  
格式: IDIV SRC  
操作: 类似DIV  

## 逻辑类指令  
- `AND`与指令  
格式:AND dst,src  
操作功能:将目的操作数与原操作数按位与
- `OR`或指令
格式:OR dst,src  
操作功能:将目的操作数与原操作数按位或
- `NOT`取反指令  
格式:NOT dst  
操作功能:0FFH-(dst)或0FFFFH-(dst)  
- `XOR`异或指令
格式:XOR dst,src
操作功能:dst和src按位异或
- `TEST`相当于AND运算,但是不保存结果,仅影响标志。
```
常见的用法举例:
(1)清进位标志位:AND AX,AX或OR AL,AL等。
(2)清零操作数:XOR AX,AX不仅把AX清零,而且影响标志位。
(3)把某几位取反:用XOR指令,把要取反的位和1异或,不变的和0异或。
(4)清零或置位某几位:用AND指令清零,用OR指令置位。
```
- 移位指令(H逻辑移位,A算术移位)  
![移位指令_高位保多余位保存在CF.png](https://i.loli.net/2020/09/07/ZwLhGHVd8MvSmuK.png)  
- 循环移位指令(O不带进位,C带进位)  
![循环移位指令.png](https://i.loli.net/2020/09/07/9BIhfeuzJO5EsQk.png)  

## 串操作  
串操作指令的特征是对数据块(字符串或数值串)进行操作,并且其中部分指令可以两个操作数同时是存储器的操作数。
- `MOVS` 串传送
- `CMPS` 串比较
- `SCAS` 串扫描
- `LODS` 串装入
- `STOS` 串送存

## 控制转移类指令
能够使程序的执行流程发生改变的指令  
1. 无条件转移  
`JMP`转移指令  
操作:有以下几种类型  
- 段内直接短转移  
```
JMP SHORT opr ;(IP)<--(IP)+Data8
```
- 段内直接近转移  
```
JMP NEAR PTR opr; (IP)<--(IP)+Data16
```
- 段内间接转移  
```
JMP WORD PTR opr (IP)<--寄存器或存储器操作数
```
- 段间直接转移  
```
JMP FAR PTR opr
```
- 段间间接转移
```
JMP DWORD PTR opr
```
2. 条件转移指令
- 判断单个标志  
ZF:JZ(JE),JNZ(JNE)  
SF:JS,JNS  
OF:JO,JNO  
PF:JP,JNP  
CF:JC,JNC  
- 判断无符号数的大小  
助记符意义:A(above):大于,B(below):小于,E(equal):等于  
JB(JNAE),JNB(JAE),JA(JNBE),JNA(JBE)  
判断CF and ZF  
- 判断有符号数大小
助记符意义:G(greater):大于,L(less):小于,E(equal):等于  
JL(JNGE),HNL(JGE),JLE(JNG),JNLE(JG)  
判断CF and ZF and SF  
- 判断CX寄存器  
JCXZ:CX=0(为0转移)  
3. 循环控制指令  
![循环指令.png](https://i.loli.net/2020/09/07/E8wgOQXFqryWS5M.png)  
4. 标志处理指令  
![标志处理指令.png](https://i.loli.net/2020/09/07/uHeRY7ENJmFlDWd.png)

# 汇编语言程序设计

## 汇编语言源程序格式 
例如编程实现多字节加法,如S=3B74AC60F8H+20D59E36C1H  
![多字节加法.png](https://i.loli.net/2020/09/07/O2ktq7s3hYQCfWb.png)
```
DATA SEGMENT                                 ;定义数据段起始语句
	DATA1 DB 0F8H,60H,0ACH,74H,3BH 			 ;定义数据
	DATA2 DB 0C1H,36H,9EH,0D5H,20H 			 ;定义数据段终止语句
DATA ENDS

CODE SEGMENT								 ;定义代码段起始语句
	ASSUME CS:CODE,DS:DATA                   ;说明段寄存器和段的关系
	START: MOV AX,DATA                       ;装填相应的段寄存器
		   MOV DS,AX                         
		   MOV CX,5
		   MOV S1,0
		   CLC                      
	LOOPER:MOV AL,DATA2[SI]                  ;完成所需功能
		   ADC DATA1[SI],AL
		   INC SI
		   DEC CX
		   JNZ LOOPER
		   MOV AH,4CH                        ;设置返回DOS
		   INT 21H
		   
CODE ENDS                                    ;定义代码终止语句

END START                                    ;程序结束

汇编语言的组织结构:汇编语言源程序采用的是分段结构，即一个汇编语言源程序由
若干段组成,每一段以SEGMENG语句开始,以ENDS语句结束,整个程序的结尾是END语句。
在代码段中下面内容是不可缺少的:
(1)定义段 (使用SEGMENT/ENDS语句定义)
(2)约定段寄存器和段的关系(即物理段和逻辑段的关系,使用一个或多个ASSUME语句实现)
(3)装填段寄存器(只装填数据型段寄存器)
(4)完成所需功能程序段
(5)设置返回DOS的方法
```

### 顺序结构
例:求两个数的平均值。这两个数分别放在X单元和Y单元中,而平均值放在Z单元中  
```
DATA SEGMENT
	X DB 8FH
	Y DB 97H
	Z DB ?
DATA ENDS

CODE STGMENT
	ASSMUE CS:CODE,DS:DATA
	START:MOV AX,DATA
		  MOV DS,AX
		  MOV AL,X
		  ADD AL,Y
		  MOV AH,0
		  ADC AH,AH
		  SHR AX,1
		  MOV Z,AL
		  MOV AH,4CH
		  INT 21H
CODE ENDS

END START
```

### 分支结构
![分支结构.png](https://i.loli.net/2020/09/07/N4QU8iKemv9Ffdx.png)  
```
DATA SEGMENT
	VARX DB -25
	VARY DB ?
DATA ENDS

CODE SEGMENT
	ASSUME CS:CODE,DS:DATA
	START:MOV AX,DATA
		  MOV DS,AX
		  MOV AL,VARX
		  CMP AL,0
		  JGE NEXT
		  MOV VARY,-1
		  JMP HALT
     ZARE:MOV VARY,0
	 HALT:MOV AH,4CH
		  INT 21H
CODE ENDS

END START
```

## 循环程序设计  

### 循环结束条件  
1. 用计数控制循环:适用于`已知循环次数`的循环程序设计  
2. 用条件控制循环:适用于`未知循环次数`的程序设计  
例:在xx单元开始的连续单元中存放有10个无符号字节数,从中找出最大者送yy单元  
```
DATA SEGMENT
	xx DB 49,38,65,12,97,13,55,27,28,85
	yy DB ?
DATA ENDS

CODE SEGMENT
	ASSUME CS:CODE,DS:DATA
	START:MOV AX,DATA
	      MOV DS,AX
		  LEA BX,XX
		  MOV AL,[BX]
		  MOV CX,9
	LOOP1:INC BX
		  CMP AL,[BX]
		  JAE NEXT
		  XCHG AL,[BX]
	 NEXT:LOOP LOOP1
		  MOV YY,AL
		  MOV AH,4CH
		  INT 21H
CODE ENDS
END START
```